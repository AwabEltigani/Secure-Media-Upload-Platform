package com.example.cloud_file_storage.AwsServices.HandleEvents;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.CopyObjectRequest;
import software.amazon.awssdk.services.s3.model.DeleteObjectRequest;
import software.amazon.awssdk.services.s3.model.NoSuchKeyException;
import software.amazon.awssdk.services.s3.model.S3Exception;
import software.amazon.awssdk.services.ses.SesClient;
import software.amazon.awssdk.services.ses.model.SesException;

import java.net.URI;
import java.net.URLDecoder;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.Map;
import java.util.Optional;

/**
 * AWS Lambda handler for processing GuardDuty malware scan results.
 * Automatically moves clean files to permanent storage or deletes infected files.
 * Notifies Spring Boot application via webhook for database updates.
 */
public class MalwareHandler implements RequestHandler<Map<String, Object>, String> {
    
    // Initialize AWS clients as static to reuse across Lambda invocations (reduces cold start time)
    private static final S3Client S3_CLIENT = S3Client.builder()
        .region(Region.US_EAST_1)
        .build();
    
    private static final SesClient SES_CLIENT = SesClient.builder()
        .region(Region.US_EAST_1)
        .build();
    
    // HTTP client for webhook calls
    private static final HttpClient HTTP_CLIENT = HttpClient.newBuilder()
        .connectTimeout(Duration.ofSeconds(10))
        .build();
    
    // Environment variables
    private static final String CLEAN_BUCKET = getEnvSafe("CLEAN_BUCKET");
    private static final String SENDER = getEnvSafe("SENDER_EMAIL");
    private static final String RECIPIENT = getEnvSafe("RECIPIENT_EMAIL");
    private static final String WEBHOOK_URL = getEnvSafe("WEBHOOK_URL");

    @Override
    public String handleRequest(Map<String, Object> event, Context context) {
        LambdaLogger logger = context.getLogger();
        String key = null;
        
        try {
            // Log full event for debugging
            logger.log("Event keys: " + event.keySet());
            
            // Validate event structure
            if (!event.containsKey("detail")) {
                logger.log("ERROR: Missing 'detail' field. Event: " + event);
                return "INVALID_EVENT_NO_DETAIL";
            }
            
            Map<String, Object> detail = (Map<String, Object>) event.get("detail");
            if (detail == null) {
                logger.log("ERROR: 'detail' is null. Event: " + event);
                return "INVALID_EVENT_NULL_DETAIL";
            }
            
            // Validate nested fields exist
            if (!detail.containsKey("scanResultDetails")) {
                logger.log("ERROR: Missing 'scanResultDetails'. Detail: " + detail);
                return "INVALID_EVENT_NO_SCAN_DETAILS";
            }
            
            if (!detail.containsKey("s3ObjectDetails")) {
                logger.log("ERROR: Missing 's3ObjectDetails'. Detail: " + detail);
                return "INVALID_EVENT_NO_S3_DETAILS";
            }
            
            Map<String, Object> scanResultDetails = (Map<String, Object>) detail.get("scanResultDetails");
            Map<String, Object> s3ObjectDetails = (Map<String, Object>) detail.get("s3ObjectDetails");
            
            String status = (String) scanResultDetails.get("scanResultStatus");
            String srcBucket = (String) s3ObjectDetails.get("bucketName");
            String rawKey = (String) s3ObjectDetails.get("objectKey");
            
            // Validate extracted values
            if (status == null || srcBucket == null || rawKey == null) {
                logger.log("ERROR: Null values - status: " + status + ", bucket: " + srcBucket + ", key: " + rawKey);
                return "INVALID_EVENT_MISSING_VALUES";
            }
            
            key = URLDecoder.decode(rawKey, StandardCharsets.UTF_8);
            logger.log(String.format("Processing: %s/%s [%s]", srcBucket, key, status));
            
            if ("THREATS_FOUND".equals(status)) {
                processInfectedFile(srcBucket, key, status, logger);
                return "THREAT_REMEDIATED";
            } else {
                processCleanFile(srcBucket, key, logger);
                return "FILE_PROMOTED";
            }
            
        } catch (NoSuchKeyException e) {
            logger.log("Idempotency: Object already processed. Key: " + key);
            return "ALREADY_PROCESSED";
        } catch (S3Exception e) {
            logger.log("S3 Error: " + e.awsErrorDetails().errorMessage());
            throw new RuntimeException("S3 operation failed", e);
        } catch (Exception e) {
            logger.log("Critical Error: " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException("Lambda execution failed", e);
        }
    }

    /**
     * Moves a clean file from quarantine to permanent storage.
     * Deletes the quarantine copy after successful move.
     * Notifies Spring Boot app to update database.
     */
    private void processCleanFile(String src, String key, LambdaLogger logger) {
        logger.log("Copying to clean bucket");
        
        CopyObjectRequest copyReq = CopyObjectRequest.builder()
            .sourceBucket(src)
            .sourceKey(key)
            .destinationBucket(CLEAN_BUCKET)
            .destinationKey(key)
            .build();
        
        S3_CLIENT.copyObject(copyReq);
        
        // Only delete after successful copy (atomic two-phase operation)
        logger.log("Deleting from quarantine");
        
        DeleteObjectRequest deleteReq = DeleteObjectRequest.builder()
            .bucket(src)
            .key(key)
            .build();
        
        S3_CLIENT.deleteObject(deleteReq);
        
        logger.log("File promoted successfully");
        
        // Notify Spring Boot app via webhook to update database
        notifyWebhook(key, "CLEAN", logger);
    }

    /**
     * Deletes an infected file and sends email alert.
     * Notifies Spring Boot app to update database.
     */
    private void processInfectedFile(String bucket, String key, String status, LambdaLogger logger) {
        // Delete immediately -> infected files should not remain in any bucket
        logger.log("Deleting infected file");
        
        DeleteObjectRequest deleteReq = DeleteObjectRequest.builder()
            .bucket(bucket)
            .key(key)
            .build();
        
        S3_CLIENT.deleteObject(deleteReq);
        
        logger.log("Infected file deleted");
        
        // Notify Spring Boot app via webhook to update database
        notifyWebhook(key, "INFECTED", logger);
        
        // Send email alert
        try {
            String body = String.format(
                "Malware Alert\n\nBucket: %s\nFile: %s\nStatus: %s\n\nAction: File has been deleted from quarantine.",
                bucket, key, status
            );
            
            SES_CLIENT.sendEmail(r -> r
                .source(SENDER)
                .destination(d -> d.toAddresses(RECIPIENT))
                .message(m -> m
                    .subject(s -> s.data("Security Alert: Malware Detected"))
                    .body(b -> b.text(t -> t.data(body)))
                )
            );
            logger.log("Alert sent");
            
        } catch (SesException e) {
            // Log warning but don't throw - file is already deleted (primary goal achieved)
            logger.log("WARNING: Email failed but file deleted: " + e.getMessage());
        }
    }

    /**
     * Notifies the Spring Boot application via webhook to update database.
     * Uses HTTP POST with JSON payload containing s3Key and status.
     */
    private void notifyWebhook(String s3Key, String status, LambdaLogger logger) {
        try {
            // Create JSON payload
            String payload = String.format(
                "{\"s3Key\": \"%s\", \"status\": \"%s\"}", 
                s3Key, status
            );
            
            logger.log("Sending webhook to: " + WEBHOOK_URL);
            logger.log("Payload: " + payload);
            
            // Build HTTP request
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(WEBHOOK_URL))
                .header("Content-Type", "application/json")
                .timeout(Duration.ofSeconds(30))
                .POST(HttpRequest.BodyPublishers.ofString(payload))
                .build();
            
            // Send request
            HttpResponse<String> response = HTTP_CLIENT.send(
                request, 
                HttpResponse.BodyHandlers.ofString()
            );
            
            logger.log("Webhook response status: " + response.statusCode());
            logger.log("Webhook response body: " + response.body());
            
            if (response.statusCode() >= 200 && response.statusCode() < 300) {
                logger.log("Webhook notification successful");
            } else {
                logger.log("WARNING: Webhook returned non-success status: " + response.statusCode());
            }
            
        } catch (Exception e) {
            // Log error but don't throw - file operations are complete
            // Database sync can be handled by scheduled job if webhook fails
            logger.log("ERROR: Webhook notification failed: " + e.getClass().getName() + " - " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Validates environment variable exists and is not blank.
     * Fails fast during Lambda initialization if configuration is missing.
     */
    private static String getEnvSafe(String name) {
        return Optional.ofNullable(System.getenv(name))
                .filter(s -> !s.isBlank())
                .orElseThrow(() -> new IllegalStateException("Missing env var: " + name));
    }
}